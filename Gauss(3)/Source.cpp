#include <iostream>
#include <math.h>
using namespace std;
int SolutionOfSLAU(double** matrix_a, int n, double* vector_b,
	double* x)
	/* Решение будет реализовано по примеру из учебного пособия
		то есть в виде функции с аргументами в виде указателей.
		Несмотря на то, что в моём случае это избыточно, ввиду
		известной заранее размерности, было решено использовать
		всё же динамические массивы. Таким образом, что задачу
		с указанным условием можно решить для А любой размерности.
		matrix_a - указатель на начало матрицы коэффициентов.
		n - размерность для удобства работы.
		vector_b - указатель на начало массива свободных членов.
		x - указатель на массив, содержащий решения.
	*/
{
	int i, j, k, r;
	double c, M, max, s;
	// Заведём копии для matrix_a и vector_b
	double** a, * b;
	// Для этого выделим для них память...
	a = new double* [n];
	for (i = 0; i < n; i++)
		a[i] = new double[n];
	b = new double[n];
	// ... и, наконец, перенесём значения.
	for (i = 0; i < n; i++)
		for (j = 0; j < n; j++)
			a[i][j] = matrix_a[i][j];
	for (i = 0; i < n; i++)
		b[i] = vector_b[i];


	// Здесь осуществляется прямой ход метода Гаусса.
	for (k = 0; k < n; k++)
	{
		// Ищём максимальный по модулю эл-т в к-ом столбце.
		max = fabs(a[k][k]);
		r = k;
		for (i = k + 1; i < n; i++)
			if (fabs(a[i][k]) > max)
			{
				max = fabs(a[i][k]);
				r = i;
			}
		// Меняем местами k-ую и r-ую строки (та, в которой найден макс. по модулю элемент)
		for (j = 0; j < n; j++)
		{
			c = a[k][j];
			a[k][j] = a[r][j];
			a[r][j] = c;
		}
		c = b[k];
		b[k] = b[r];
		b[r] = c;
		// Теперь начнём приведение матрицы к диагональному виду по алгоритму метода
		for (i = k + 1; i < n; i++)
		{
			for (M = a[i][k] / a[k][k], j = k; j < n; j++)
				a[i][j] -= M * a[k][j];
			b[i] -= M * b[k];
		}
	}
		// Здесь осуществляется обратный ход метода Гаусса
		if (a[n - 1][n - 1] == 0)
			if (b[n - 1] == 0)
				//Cистема имеет бесконечное множество решений, если:
				// последний диагональный элемент И последний коэффициент вектора своб. членов равны 0.
				return -1;
		// система решений не имеет, если последний коэффициент вектора своб. членов не равен 0.
			else return -2;
		else
			// Начинаем обратный ход метода Гаусса, если последний диагональный элемент не равен 0.
		{
			for (i = n - 1; i >= 0; i--)
			{
				for (s = 0, j = i + 1; j < n; j++)
					s += a[i][j] * x[j];
				x[i] = (b[i] - s) / a[i][i];
			}
			return 0;
		}
	}

int main() {
	system("color 80");
	setlocale(LC_ALL, "Russian"); // Делаю доступным русский язык для вывода в консоль.
	int result, i, j, N;
	double** a, ** A, * b, * x;
	// Размерность матрицы коэффициентов равна 4, однако её можно менять. Поменяется и размерность вектора правых частей.
	cout << "Размерность матрицы коэффициентов";
	cin >> N;
	// Выделение памяти для матрицы коэффициентов и вектора свободных членов так же, как и для вектора решений.
	a = new double* [N];
	for (i = 0; i < N; i++)
		a[i] = new double[N];
	b = new double[N];
	x = new double[N];

	// Считывание матрицы коэффициентов и вектора свободных членов.
	cout << "Введите матрицу A построчно: " << endl;
	for (i = 0; i < N; i++)
		for (j = 0; j < N; j++)
			cin >> a[i][j];
	cout << "----------------------------" << endl;

	cout << "Введите вектор B: " << endl;
	for (i = 0; i < N; i++)
		cin >> b[i];
	
	cout << "----------------------------" << endl;


	/* Здесь вызываю функцию решения СЛАУ. В переменную результат
		записывается значение в зависимости от наличия или отсутствия
		корней.
		Result = 0 -> система имеет единственное решение,
		Result = -1 -> система имеет бесконечное мн-во решений.
		Result = -2 -> решений не имеется. */
	result = SolutionOfSLAU(a, N, b, x);
	if (result == 0)
	{
		// Вывод вектора решений
		cout << "Решения в виде вектора х: " << endl;
		for (i = 0; i < N; i++)
			if (i != N - 1)
				cout << " (" << x[i] << "),  ";
			else cout << " (" << x[i] << ").";
		cout << endl;
	}
	else if (result == -1)
		cout << "Система имеет бесконечное множество решений" << endl;
	else if (result == -2)
		cout << "Решений не имеется" << endl;
}
